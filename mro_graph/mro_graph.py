#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# Python MRO-graph generator
# ==========================
# Copyright (C) 2003 Michele Simionato
# Copyright (C) 2019-2020 Heiko 'riot' Weinen
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
Draw inheritance hierarchies via Dot (http://www.graphviz.org/)
Author: Michele Simionato (and Heiko 'riot' Weinen)
E-mail: mis6@pitt.edu
Date: August 2003, 2019-2020
License: GPLv3
Requires: Python 2 or Python 3, dot, standard Unix tools
"""

import os
import itertools

import click


DEFAULT_PS_VIEWER_EXECUTABLE = "gv"
DEFAULT_PNG_VIEWER_EXECUTABLE = "display"
DEFAULT_PS_FONT = "Times"
DEFAULT_PNG_FONT = ""


def mro(cls):
    """Returns the MRO of cls as a text"""

    out = ["MRO of %s:" % cls.__name__]
    for counter, c in enumerate(cls.__mro__):
        name = c.__name__
        bases = ",".join([b.__name__ for b in c.__bases__])
        s = "  %s - %s(%s)" % (counter, name, bases)
        if type(c) is not type:
            s += "[%s]" % type(c).__name__
        out.append(s)
    return "\n".join(out)


def quote_id(s):
    """
    Quote a Graphviz ID.
    """
    # according to https://www.graphviz.org/doc/info/lang.html backslash need not be escaped
    # which means odd number of trailing backslash cannot be escaped
    # we don't test for it here
    return '"' + s.replace('"', r'\"') + '"'


class MROGraph(object):
    def __init__(self, *classes, **options):
        """Generates the MRO graph of a set of given classes.

        Arguments:
            :type classes: object

        Options:
            filename TEXT    Specify filename or use autogenerated
            legend           Add a legend
            setup TEXT       Additional dot setup code (Default: '')
            ps_viewer TEXT   Specify postscript viewer to use (Default: gv)
            png_viewer TEXT  Specify png viewer to use (Default: display)
            ps_font TEXT     Specify font for postscript rendering (Default: Times)
            png_font TEXT    Specify font for png rendering (Default: )


        """

        self.labels = options.get("labels", 2)

        filename = options.get("filename", None)
        if filename is None:
            filename = "MRO_of_%s.ps" % classes[0].__name__

        legend = options.get("legend", False)
        setup = options.get("setup", "")
        ps_viewer = options.get("ps_viewer", DEFAULT_PS_VIEWER_EXECUTABLE)
        png_viewer = options.get("png_viewer", DEFAULT_PNG_VIEWER_EXECUTABLE)

        ps_font = options.get("ps_font", DEFAULT_PS_FONT)
        png_font = options.get("png_font", DEFAULT_PNG_FONT)
        name, dot_format = os.path.splitext(filename)
        file_format = dot_format[1:]

        font_options = "fontname=" + ps_font if file_format == "ps" else png_font
        node_options = " node [%s];\n" % font_options
        edge_options = " edge [%s];\n" % font_options

        viewer = ps_viewer if file_format == "ps" else png_viewer

        # noinspection PyTypeChecker
        self.text_repr = "\n".join([mro(cls) for cls in classes])

        legend = (
            'legend [shape=box,label="%s\n",fontsize=9];' % self.text_repr
            if legend
            else ""
        )
        legend = legend.replace("\n", "\\l")

        setup_code = node_options + edge_options + legend + "\n" + setup + "\n"

        # noinspection PyTypeChecker
        code_iter = itertools.chain(
            *[self.generate_mro_dot_code(cls) for cls in classes]
        )

        self.dot_code = "digraph %s{\n%s%s}" % (quote_id(name), setup_code, "\n".join(code_iter))

        if file_format == "dot":
            with open(filename, "w") as f:
                f.write(self.dot_code)
        else:
            # noinspection StandardShellInjection
            os.system(
                "echo '%s' | dot -T%s > %s; %s %s&"
                % (self.dot_code, file_format, filename, viewer, filename)
            )

    def generate_mro_dot_code(self, cls):
        """Generates the dot code for the MRO of a given class"""

        for mro_index, c in enumerate(cls.__mro__):
            name = c.__name__
            many_parents = len(c.__bases__) > 1
            if c.__bases__:
                yield "".join(
                    [
                        " edge [style=solid]; %s -> %s %s;\n"
                        % (
                            quote_id(b.__name__),
                            quote_id(name),
                            '[label="%s"]' % (i + 1)
                            if many_parents and self.labels == 2
                            else "",
                        )
                        for i, b in enumerate(c.__bases__)
                    ]
                )
            if many_parents:
                yield " {rank=same; %s}\n" % "".join(
                    ['"%s"; ' % b.__name__ for b in c.__bases__]
                )
            number = "%s-" % mro_index if self.labels else ""
            label = 'label="%s"' % (number + name)
            option = (
                "[%s]" % label if issubclass(cls, type) else "[shape=box,%s]" % label
            )
            yield " %s %s;\n" % (quote_id(name), option)
            if type(c) is not type:  # c has a custom metaclass
                meta_name = type(c).__name__
                yield " edge [style=dashed]; %s -> %s;" % (quote_id(meta_name), quote_id(name))

    def __repr__(self):
        """Returns the Dot representation of the graph"""
        return self.dot_code

    def __str__(self):
        """Returns a text representation of the MRO"""
        return self.text_repr


@click.command()
@click.option("--filename", help="Specify filename or use autogenerated", default=None)
@click.option("--legend", help="Add a legend", is_flag=True, default=False)
@click.option("--setup", help="Additional dot setup code (Default: '')", default="")
@click.option(
    "--ps-viewer",
    help="Specify postscript viewer to use (Default: %s)"
    % DEFAULT_PS_VIEWER_EXECUTABLE,
    default=DEFAULT_PS_VIEWER_EXECUTABLE,
)
@click.option(
    "--png-viewer",
    help="Specify png viewer to use (Default: %s)" % DEFAULT_PNG_VIEWER_EXECUTABLE,
    default=DEFAULT_PNG_VIEWER_EXECUTABLE,
)
@click.option(
    "--ps-font",
    help="Specify font for postscript rendering (Default: %s)" % DEFAULT_PS_FONT,
    default=DEFAULT_PS_FONT,
)
@click.option(
    "--png-font",
    help="Specify font for png rendering (Default: %s)" % DEFAULT_PNG_FONT,
    default=DEFAULT_PNG_FONT,
)
@click.argument("import_exec")
@click.argument("name_eval")
def main(**kwargs):
    """
    MRO Graph generator

    A tool to inspect the method resolution order of arbitrary Python objects.

    \b
    IMPORT_EXEC - import statement to execute
    NAME_EVAL   - object to inspect

    The format to export is determined by the filename extension.
    Allowed extensions are "png", "ps" or "dot".

    Caution: missing fonts may cause dot to bail out with syntax errors in line 2
    """

    # noinspection BuiltinExec
    exec(kwargs["import_exec"])

    object_to_inspect = eval(kwargs["name_eval"])

    MROGraph(object_to_inspect, **kwargs)


if __name__ == "__main__":
    main()
